/*
 * Vector.h
 *
 *  Created on: Dec 9, 2010
 *      Author: papazov
 */

#ifndef VECTOR_H_
#define VECTOR_H_

#include <iostream>
#include <cmath>

#define V_SQR(x) ((x)*(x))

namespace btl1
{

//=== inline methods =================================================================================================

inline double vec_box_sqr_diag_len(const double b[6])
{
	return V_SQR(b[0]-b[1]) + V_SQR(b[2]-b[3]) + V_SQR(b[4]-b[5]);
}

//====================================================================================================================

inline void vec_flip3(double *v)
{
	v[0] = -v[0];
	v[1] = -v[1];
	v[2] = -v[2];
}

//====================================================================================================================

inline void vec_flip2(double *u)
{
	u[0] = -u[0];
	u[1] = -u[1];
}

//====================================================================================================================

inline void vec_flip3(const double *v, double *flipped)
{
	flipped[0] = -v[0];
	flipped[1] = -v[1];
	flipped[2] = -v[2];
}

//====================================================================================================================

inline void vec_normalize3(double* v)
{
	double inv_len = 1.0/sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);
	v[0] *= inv_len;
	v[1] *= inv_len;
	v[2] *= inv_len;
}

//====================================================================================================================

inline void vec_normalize2(double* u)
{
	double inv_len = 1.0/sqrt(u[0]*u[0] + u[1]*u[1]);
	u[0] *= inv_len;
	u[1] *= inv_len;
}

//====================================================================================================================

inline void vec_normalize3(const double* v, double* out)
{
	double inv_len = 1.0/sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);
	out[0] = inv_len*v[0];
	out[1] = inv_len*v[1];
	out[2] = inv_len*v[2];
}

//====================================================================================================================

inline void vec_cross3(const double *v1, const double *v2, double *out)
{
	out[0] = v1[1]*v2[2] - v1[2]*v2[1];
	out[1] = v1[2]*v2[0] - v1[0]*v2[2];
	out[2] = v1[0]*v2[1] - v1[1]*v2[0];
}

//====================================================================================================================

inline double vec_dot3(const double *v1, const double *v2)
{
	return v1[0]*v2[0] + v1[1]*v2[1] + v1[2]*v2[2];
}

//====================================================================================================================

inline double vec_dot2(const double *v1, const double *v2)
{
	return v1[0]*v2[0] + v1[1]*v2[1];
}

//====================================================================================================================

/** Rotates 'u' counter clock wise by 90Â° and saves the result in 'out'. The vectors should be 2D. */
inline void vec_rotate_90_deg2(const double *u, double *out)
{
	out[0] = -u[1];
	out[1] =  u[0];
}

//====================================================================================================================

/** v += a. */
inline void vec_add3(double *v, const double *a)
{
	v[0] += a[0];
	v[1] += a[1];
	v[2] += a[2];
}

//====================================================================================================================

/** v -= a. */
inline void vec_sub3(double *v, const double *a)
{
	v[0] -= a[0];
	v[1] -= a[1];
	v[2] -= a[2];
}

//====================================================================================================================

inline void vec_set3(double *v, const double s)
{
	v[0] = v[1] = v[2] = s;
}

//====================================================================================================================

inline void vec_mult3(double *v, const double s)
{
	v[0] *= s;
	v[1] *= s;
	v[2] *= s;
}

//====================================================================================================================

inline void vec_mult3(const double *v, const double s, double* out)
{
	out[0] = s*v[0];
	out[1] = s*v[1];
	out[2] = s*v[2];
}

//====================================================================================================================

inline double vec_dist3(const double a[3], const double b[3])
{
	return sqrt(V_SQR(a[0]-b[0]) + V_SQR(a[1]-b[1]) + V_SQR(a[2]-b[2]));
}

//====================================================================================================================

inline double vec_dist3L1(const double* a, const double* b)
{
	return fabs(a[0]-b[0]) + fabs(a[1]-b[1]) + fabs(a[2]-b[2]);
}

//====================================================================================================================

inline double vec_sqr_dist3(const double a[3], const double b[3])
{
	return V_SQR(a[0]-b[0]) + V_SQR(a[1]-b[1]) + V_SQR(a[2]-b[2]);
}

//====================================================================================================================

template<int N, class T>
inline void vec_copy(const T *src, T *dst)
{
	for ( int i = 0 ; i < N ; ++i )
		dst[i] = src[i];
}

//====================================================================================================================

inline void vec_copy3(const double *src, double *dst)
{
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
}

//====================================================================================================================

inline void vec_copy2(const double *src, double *dst)
{
	dst[0] = src[0];
	dst[1] = src[1];
}

//====================================================================================================================

template <class T>
inline void vec_copy12(const T* src, T* dst)
{
	dst[0]  = src[0];
	dst[1]  = src[1];
	dst[2]  = src[2];
	dst[3]  = src[3];
	dst[4]  = src[4];
	dst[5]  = src[5];
	dst[6]  = src[6];
	dst[7]  = src[7];
	dst[8]  = src[8];
	dst[9]  = src[9];
	dst[10] = src[10];
	dst[11] = src[11];
}

//====================================================================================================================

inline void vec_copy_d2f_12(const double* src, float* dst)
{
	dst[0]  = (float)src[0];
	dst[1]  = (float)src[1];
	dst[2]  = (float)src[2];
	dst[3]  = (float)src[3];
	dst[4]  = (float)src[4];
	dst[5]  = (float)src[5];
	dst[6]  = (float)src[6];
	dst[7]  = (float)src[7];
	dst[8]  = (float)src[8];
	dst[9]  = (float)src[9];
	dst[10] = (float)src[10];
	dst[11] = (float)src[11];
}

//====================================================================================================================

/** %out = %a - %b. */
inline void vec_diff3(const double *a, const double *b, double *out)
{
	out[0] = a[0] - b[0];
	out[1] = a[1] - b[1];
	out[2] = a[2] - b[2];
}

//====================================================================================================================

/** %out = %a - %b. */
inline void vec_diff2(const double *a, const double *b, double *out)
{
	out[0] = a[0] - b[0];
	out[1] = a[1] - b[1];
}

//====================================================================================================================

/** %out = %a + %b */
inline void vec_sum3(const double *a, const double *b, double *out)
{
	out[0] = a[0] + b[0];
	out[1] = a[1] + b[1];
	out[2] = a[2] + b[2];
}

//====================================================================================================================

inline double vec_length3(const double *v)
{
	return sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);
}

//====================================================================================================================

inline double vec_length2(const double *v)
{
	return sqrt(v[0]*v[0] + v[1]*v[1]);
}

//====================================================================================================================

inline void vec_set_to_length3(double *v, double length)
{
	double s = length/vec_length3(v);
	v[0] *= s;
	v[1] *= s;
	v[2] *= s;
}

//====================================================================================================================

inline double vec_sqr_length3(const double *v)
{
	return v[0]*v[0] + v[1]*v[1] + v[2]*v[2];
}

//====================================================================================================================

/** Swaps the elements at positions 'i' and 'j' in the vector 'v'. */
inline void vec_swap(double *v, int i, int j)
{
	double tmp = v[i];
	v[i] = v[j];
	v[j] = tmp;
}

//====================================================================================================================

template <class T, int N>
inline void vec_print(T* v)
{
	std::cout << "(";
	for ( int i = 0 ; i < N ; ++i ) std::cout << " " << v[i] << " ";
	std::cout << ")\n";
}

//====================================================================================================================

}//namespace btl1

#endif /* VECTOR_H_ */
